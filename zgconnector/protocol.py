import asyncio
import logging
import time

from zgconnector.state import State
from zgconnector.packet import Packet, PACKET_SIZE
from zgconnector.commands import commands, transfer
from zgconnector.exceptions import PacketException


class Protocol(asyncio.Protocol):
    def __init__(self, server):
        self.server = server
        self._buffer = bytearray()
        self.state = State.INIT
        self.heartbeat_at = time.time()
        self.packet = None

    def connection_made(self, transport):
        self.transport = transport

    def data_received(self, data):
        self._buffer += data
        while self._buffer:
            if self.state == State.INIT:
                if len(self._buffer) < PACKET_SIZE:
                    return
                msg, self._buffer = self._buffer[:PACKET_SIZE], self._buffer[PACKET_SIZE:]
                try:
                    self.packet = Packet.unpack(msg)
                except PacketException:
                    logging.debug(f'failed to parse message: {msg}')
                    self.state = State.INIT
                    self.transport.close()
                    return
                if self.packet.token != self.server.token:
                    logging.debug(f"invalid token: {self.packet.token}")
                    self.transport.close()
                logging.debug(f"cmd: {self.packet.cmd} from {self.packet.from_} to {self.packet.to}, length {self.packet.length}")
                self.state = State.REQUEST
            if self.state == State.REQUEST:
                if len(self._buffer) < self.packet.length:
                    return
                msg, self._buffer = self._buffer[:self.packet.length], self._buffer[self.packet.length:]
                self.packet.body = msg
                logging.debug(f"content: {self.packet.body}")
                command = commands.get(self.packet.cmd) or transfer
                self.server.loop.create_task(command(self))
                self.state = State.INIT


    def eof_received(self):
        if self.transport.can_write_eof():
            self.transport.write_eof()

    def connection_lost(self, exc):
        try:
            logging.debug(f"got connection lost from {self.packet.from_}")
        except Exception:
            pass

        super().connection_lost(exc)